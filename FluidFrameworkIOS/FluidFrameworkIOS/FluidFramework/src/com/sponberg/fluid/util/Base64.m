//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: src-delomboked/com/sponberg/fluid/util/Base64.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "com/sponberg/fluid/util/Base64.h"
#include "java/io/BufferedInputStream.h"
#include "java/io/BufferedOutputStream.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/io/File.h"
#include "java/io/FileInputStream.h"
#include "java/io/FileOutputStream.h"
#include "java/io/FilterInputStream.h"
#include "java/io/FilterOutputStream.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/io/ObjectInputStream.h"
#include "java/io/ObjectOutputStream.h"
#include "java/io/ObjectStreamClass.h"
#include "java/io/OutputStream.h"
#include "java/io/Serializable.h"
#include "java/io/UnsupportedEncodingException.h"
#include "java/lang/ClassLoader.h"
#include "java/lang/ClassNotFoundException.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/System.h"
#include "java/nio/ByteBuffer.h"
#include "java/nio/CharBuffer.h"
#include "java/util/zip/GZIPInputStream.h"
#include "java/util/zip/GZIPOutputStream.h"

BOOL FFTBase64_initialized = NO;

@implementation FFTBase64

NSString * FFTBase64_PREFERRED_ENCODING_ = @"US-ASCII";
IOSByteArray * FFTBase64__STANDARD_ALPHABET_;
IOSByteArray * FFTBase64__STANDARD_DECODABET_;
IOSByteArray * FFTBase64__URL_SAFE_ALPHABET_;
IOSByteArray * FFTBase64__URL_SAFE_DECODABET_;
IOSByteArray * FFTBase64__ORDERED_ALPHABET_;
IOSByteArray * FFTBase64__ORDERED_DECODABET_;

+ (IOSByteArray *)getAlphabetWithInt:(int)options {
  if ((options & FFTBase64_URL_SAFE) == FFTBase64_URL_SAFE) {
    return FFTBase64__URL_SAFE_ALPHABET_;
  }
  else if ((options & FFTBase64_ORDERED) == FFTBase64_ORDERED) {
    return FFTBase64__ORDERED_ALPHABET_;
  }
  else {
    return FFTBase64__STANDARD_ALPHABET_;
  }
}

+ (IOSByteArray *)getDecodabetWithInt:(int)options {
  if ((options & FFTBase64_URL_SAFE) == FFTBase64_URL_SAFE) {
    return FFTBase64__URL_SAFE_DECODABET_;
  }
  else if ((options & FFTBase64_ORDERED) == FFTBase64_ORDERED) {
    return FFTBase64__ORDERED_DECODABET_;
  }
  else {
    return FFTBase64__STANDARD_DECODABET_;
  }
}

- (id)init {
  return [super init];
}

+ (IOSByteArray *)encode3to4WithByteArray:(IOSByteArray *)b4
                            withByteArray:(IOSByteArray *)threeBytes
                                  withInt:(int)numSigBytes
                                  withInt:(int)options {
  (void) [FFTBase64 encode3to4WithByteArray:threeBytes withInt:0 withInt:numSigBytes withByteArray:b4 withInt:0 withInt:options];
  return b4;
}

+ (IOSByteArray *)encode3to4WithByteArray:(IOSByteArray *)source
                                  withInt:(int)srcOffset
                                  withInt:(int)numSigBytes
                            withByteArray:(IOSByteArray *)destination
                                  withInt:(int)destOffset
                                  withInt:(int)options {
  IOSByteArray *ALPHABET = [FFTBase64 getAlphabetWithInt:options];
  int inBuff = (numSigBytes > 0 ? ((int) (((unsigned int) (IOSByteArray_Get(nil_chk(source), srcOffset) << 24)) >> 8)) : 0) | (numSigBytes > 1 ? ((int) (((unsigned int) (IOSByteArray_Get(nil_chk(source), srcOffset + 1) << 24)) >> 16)) : 0) | (numSigBytes > 2 ? ((int) (((unsigned int) (IOSByteArray_Get(nil_chk(source), srcOffset + 2) << 24)) >> 24)) : 0);
  switch (numSigBytes) {
    case 3:
    (*IOSByteArray_GetRef(nil_chk(destination), destOffset)) = IOSByteArray_Get(nil_chk(ALPHABET), ((int) (((unsigned int) inBuff) >> 18)));
    (*IOSByteArray_GetRef(destination, destOffset + 1)) = IOSByteArray_Get(ALPHABET, ((int) (((unsigned int) inBuff) >> 12)) & (int) 0x3f);
    (*IOSByteArray_GetRef(destination, destOffset + 2)) = IOSByteArray_Get(ALPHABET, ((int) (((unsigned int) inBuff) >> 6)) & (int) 0x3f);
    (*IOSByteArray_GetRef(destination, destOffset + 3)) = IOSByteArray_Get(ALPHABET, (inBuff) & (int) 0x3f);
    return destination;
    case 2:
    (*IOSByteArray_GetRef(nil_chk(destination), destOffset)) = IOSByteArray_Get(nil_chk(ALPHABET), ((int) (((unsigned int) inBuff) >> 18)));
    (*IOSByteArray_GetRef(destination, destOffset + 1)) = IOSByteArray_Get(ALPHABET, ((int) (((unsigned int) inBuff) >> 12)) & (int) 0x3f);
    (*IOSByteArray_GetRef(destination, destOffset + 2)) = IOSByteArray_Get(ALPHABET, ((int) (((unsigned int) inBuff) >> 6)) & (int) 0x3f);
    (*IOSByteArray_GetRef(destination, destOffset + 3)) = FFTBase64_EQUALS_SIGN;
    return destination;
    case 1:
    (*IOSByteArray_GetRef(nil_chk(destination), destOffset)) = IOSByteArray_Get(nil_chk(ALPHABET), ((int) (((unsigned int) inBuff) >> 18)));
    (*IOSByteArray_GetRef(destination, destOffset + 1)) = IOSByteArray_Get(ALPHABET, ((int) (((unsigned int) inBuff) >> 12)) & (int) 0x3f);
    (*IOSByteArray_GetRef(destination, destOffset + 2)) = FFTBase64_EQUALS_SIGN;
    (*IOSByteArray_GetRef(destination, destOffset + 3)) = FFTBase64_EQUALS_SIGN;
    return destination;
    default:
    return destination;
  }
}

+ (void)encodeWithJavaNioByteBuffer:(JavaNioByteBuffer *)raw
              withJavaNioByteBuffer:(JavaNioByteBuffer *)encoded {
  IOSByteArray *raw3 = [IOSByteArray arrayWithLength:3];
  IOSByteArray *enc4 = [IOSByteArray arrayWithLength:4];
  while ([((JavaNioByteBuffer *) nil_chk(raw)) hasRemaining]) {
    int rem = [JavaLangMath minWithInt:3 withInt:[raw remaining]];
    (void) [raw getWithByteArray:raw3 withInt:0 withInt:rem];
    (void) [FFTBase64 encode3to4WithByteArray:enc4 withByteArray:raw3 withInt:rem withInt:FFTBase64_NO_OPTIONS];
    (void) [((JavaNioByteBuffer *) nil_chk(encoded)) putWithByteArray:enc4];
  }
}

+ (void)encodeWithJavaNioByteBuffer:(JavaNioByteBuffer *)raw
              withJavaNioCharBuffer:(JavaNioCharBuffer *)encoded {
  IOSByteArray *raw3 = [IOSByteArray arrayWithLength:3];
  IOSByteArray *enc4 = [IOSByteArray arrayWithLength:4];
  while ([((JavaNioByteBuffer *) nil_chk(raw)) hasRemaining]) {
    int rem = [JavaLangMath minWithInt:3 withInt:[raw remaining]];
    (void) [raw getWithByteArray:raw3 withInt:0 withInt:rem];
    (void) [FFTBase64 encode3to4WithByteArray:enc4 withByteArray:raw3 withInt:rem withInt:FFTBase64_NO_OPTIONS];
    for (int i = 0; i < 4; i++) {
      (void) [((JavaNioCharBuffer *) nil_chk(encoded)) putWithChar:(unichar) (IOSByteArray_Get(enc4, i) & (int) 0xFF)];
    }
  }
}

+ (NSString *)encodeObjectWithJavaIoSerializable:(id<JavaIoSerializable>)serializableObject {
  return [FFTBase64 encodeObjectWithJavaIoSerializable:serializableObject withInt:FFTBase64_NO_OPTIONS];
}

+ (NSString *)encodeObjectWithJavaIoSerializable:(id<JavaIoSerializable>)serializableObject
                                         withInt:(int)options {
  if (serializableObject == nil) {
    @throw [[JavaLangNullPointerException alloc] initWithNSString:@"Cannot serialize a null object."];
  }
  JavaIoByteArrayOutputStream *baos = nil;
  JavaIoOutputStream *b64os = nil;
  JavaUtilZipGZIPOutputStream *gzos = nil;
  JavaIoObjectOutputStream *oos = nil;
  @try {
    baos = [[JavaIoByteArrayOutputStream alloc] init];
    b64os = [[FFTBase64_OutputStream alloc] initWithJavaIoOutputStream:baos withInt:FFTBase64_ENCODE | options];
    if ((options & FFTBase64_GZIP) != 0) {
      gzos = [[JavaUtilZipGZIPOutputStream alloc] initWithJavaIoOutputStream:b64os];
      oos = [[JavaIoObjectOutputStream alloc] initWithJavaIoOutputStream:gzos];
    }
    else {
      oos = [[JavaIoObjectOutputStream alloc] initWithJavaIoOutputStream:b64os];
    }
    [((JavaIoObjectOutputStream *) nil_chk(oos)) writeObjectWithId:serializableObject];
  }
  @catch (JavaIoIOException *e) {
    @throw e;
  }
  @finally {
    @try {
      [((JavaIoObjectOutputStream *) nil_chk(oos)) close];
    }
    @catch (JavaLangException *e) {
    }
    @try {
      [((JavaUtilZipGZIPOutputStream *) nil_chk(gzos)) close];
    }
    @catch (JavaLangException *e) {
    }
    @try {
      [((JavaIoOutputStream *) nil_chk(b64os)) close];
    }
    @catch (JavaLangException *e) {
    }
    @try {
      [((JavaIoByteArrayOutputStream *) nil_chk(baos)) close];
    }
    @catch (JavaLangException *e) {
    }
  }
  @try {
    return [NSString stringWithBytes:[((JavaIoByteArrayOutputStream *) nil_chk(baos)) toByteArray] charsetName:FFTBase64_PREFERRED_ENCODING_];
  }
  @catch (JavaIoUnsupportedEncodingException *uue) {
    return [NSString stringWithBytes:[((JavaIoByteArrayOutputStream *) nil_chk(baos)) toByteArray]];
  }
}

+ (NSString *)encodeBytesWithByteArray:(IOSByteArray *)source {
  NSString *encoded = nil;
  @try {
    encoded = [FFTBase64 encodeBytesWithByteArray:source withInt:0 withInt:(int) [((IOSByteArray *) nil_chk(source)) count] withInt:FFTBase64_NO_OPTIONS];
  }
  @catch (JavaIoIOException *ex) {
    NSAssert(NO, [[((JavaIoIOException *) nil_chk(ex)) getMessage] description]);
  }
  NSAssert(encoded != nil, @"src-delomboked/com/sponberg/fluid/util/Base64.java:725 condition failed: assert encoded != null;");
  return encoded;
}

+ (NSString *)encodeBytesWithByteArray:(IOSByteArray *)source
                               withInt:(int)options {
  return [FFTBase64 encodeBytesWithByteArray:source withInt:0 withInt:(int) [((IOSByteArray *) nil_chk(source)) count] withInt:options];
}

+ (NSString *)encodeBytesWithByteArray:(IOSByteArray *)source
                               withInt:(int)off
                               withInt:(int)len {
  NSString *encoded = nil;
  @try {
    encoded = [FFTBase64 encodeBytesWithByteArray:source withInt:off withInt:len withInt:FFTBase64_NO_OPTIONS];
  }
  @catch (JavaIoIOException *ex) {
    NSAssert(NO, [[((JavaIoIOException *) nil_chk(ex)) getMessage] description]);
  }
  NSAssert(encoded != nil, @"src-delomboked/com/sponberg/fluid/util/Base64.java:793 condition failed: assert encoded != null;");
  return encoded;
}

+ (NSString *)encodeBytesWithByteArray:(IOSByteArray *)source
                               withInt:(int)off
                               withInt:(int)len
                               withInt:(int)options {
  IOSByteArray *encoded = [FFTBase64 encodeBytesToBytesWithByteArray:source withInt:off withInt:len withInt:options];
  @try {
    return [NSString stringWithBytes:encoded charsetName:FFTBase64_PREFERRED_ENCODING_];
  }
  @catch (JavaIoUnsupportedEncodingException *uue) {
    return [NSString stringWithBytes:encoded];
  }
}

+ (IOSByteArray *)encodeBytesToBytesWithByteArray:(IOSByteArray *)source {
  IOSByteArray *encoded = nil;
  @try {
    encoded = [FFTBase64 encodeBytesToBytesWithByteArray:source withInt:0 withInt:(int) [((IOSByteArray *) nil_chk(source)) count] withInt:FFTBase64_NO_OPTIONS];
  }
  @catch (JavaIoIOException *ex) {
    NSAssert(NO, [[NSString stringWithFormat:@"IOExceptions only come from GZipping J2OBJC_COMMA() which is turned off: %@" J2OBJC_COMMA() [((JavaIoIOException *) nil_chk(ex)) getMessage]] description]);
  }
  return encoded;
}

+ (IOSByteArray *)encodeBytesToBytesWithByteArray:(IOSByteArray *)source
                                          withInt:(int)off
                                          withInt:(int)len
                                          withInt:(int)options {
  if (source == nil) {
    @throw [[JavaLangNullPointerException alloc] initWithNSString:@"Cannot serialize a null array."];
  }
  if (off < 0) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:[NSString stringWithFormat:@"Cannot have negative offset: %d", off]];
  }
  if (len < 0) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:[NSString stringWithFormat:@"Cannot have length offset: %d", len]];
  }
  if (off + len > (int) [((IOSByteArray *) nil_chk(source)) count]) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:[NSString formatWithNSString:@"Cannot have offset of %d and length of %d with array of length %d" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ [JavaLangInteger valueOfWithInt:off], [JavaLangInteger valueOfWithInt:len], [JavaLangInteger valueOfWithInt:(int) [source count]] } count:3 type:[IOSClass classWithClass:[NSObject class]]]]];
  }
  if ((options & FFTBase64_GZIP) != 0) {
    JavaIoByteArrayOutputStream *baos = nil;
    JavaUtilZipGZIPOutputStream *gzos = nil;
    FFTBase64_OutputStream *b64os = nil;
    @try {
      baos = [[JavaIoByteArrayOutputStream alloc] init];
      b64os = [[FFTBase64_OutputStream alloc] initWithJavaIoOutputStream:baos withInt:FFTBase64_ENCODE | options];
      gzos = [[JavaUtilZipGZIPOutputStream alloc] initWithJavaIoOutputStream:b64os];
      [gzos writeWithByteArray:source withInt:off withInt:len];
      [gzos close];
    }
    @catch (JavaIoIOException *e) {
      @throw e;
    }
    @finally {
      @try {
        [((JavaUtilZipGZIPOutputStream *) nil_chk(gzos)) close];
      }
      @catch (JavaLangException *e) {
      }
      @try {
        [((FFTBase64_OutputStream *) nil_chk(b64os)) close];
      }
      @catch (JavaLangException *e) {
      }
      @try {
        [((JavaIoByteArrayOutputStream *) nil_chk(baos)) close];
      }
      @catch (JavaLangException *e) {
      }
    }
    return [((JavaIoByteArrayOutputStream *) nil_chk(baos)) toByteArray];
  }
  else {
    BOOL breakLines = (options & FFTBase64_DO_BREAK_LINES) != 0;
    int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);
    if (breakLines) {
      encLen += encLen / FFTBase64_MAX_LINE_LENGTH;
    }
    IOSByteArray *outBuff = [IOSByteArray arrayWithLength:encLen];
    int d = 0;
    int e = 0;
    int len2 = len - 2;
    int lineLength = 0;
    for (; d < len2; d += 3, e += 4) {
      (void) [FFTBase64 encode3to4WithByteArray:source withInt:d + off withInt:3 withByteArray:outBuff withInt:e withInt:options];
      lineLength += 4;
      if (breakLines && lineLength >= FFTBase64_MAX_LINE_LENGTH) {
        (*IOSByteArray_GetRef(outBuff, e + 4)) = FFTBase64_NEW_LINE;
        e++;
        lineLength = 0;
      }
    }
    if (d < len) {
      (void) [FFTBase64 encode3to4WithByteArray:source withInt:d + off withInt:len - d withByteArray:outBuff withInt:e withInt:options];
      e += 4;
    }
    if (e <= (int) [outBuff count] - 1) {
      IOSByteArray *finalOut = [IOSByteArray arrayWithLength:e];
      [JavaLangSystem arraycopyWithId:outBuff withInt:0 withId:finalOut withInt:0 withInt:e];
      return finalOut;
    }
    else {
      return outBuff;
    }
  }
}

+ (int)decode4to3WithByteArray:(IOSByteArray *)source
                       withInt:(int)srcOffset
                 withByteArray:(IOSByteArray *)destination
                       withInt:(int)destOffset
                       withInt:(int)options {
  if (source == nil) {
    @throw [[JavaLangNullPointerException alloc] initWithNSString:@"Source array was null."];
  }
  if (destination == nil) {
    @throw [[JavaLangNullPointerException alloc] initWithNSString:@"Destination array was null."];
  }
  if (srcOffset < 0 || srcOffset + 3 >= (int) [((IOSByteArray *) nil_chk(source)) count]) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:[NSString formatWithNSString:@"Source array with length %d cannot have offset of %d and still process four bytes." withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ [JavaLangInteger valueOfWithInt:(int) [((IOSByteArray *) nil_chk(source)) count]], [JavaLangInteger valueOfWithInt:srcOffset] } count:2 type:[IOSClass classWithClass:[NSObject class]]]]];
  }
  if (destOffset < 0 || destOffset + 2 >= (int) [((IOSByteArray *) nil_chk(destination)) count]) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:[NSString formatWithNSString:@"Destination array with length %d cannot have offset of %d and still store three bytes." withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ [JavaLangInteger valueOfWithInt:(int) [((IOSByteArray *) nil_chk(destination)) count]], [JavaLangInteger valueOfWithInt:destOffset] } count:2 type:[IOSClass classWithClass:[NSObject class]]]]];
  }
  IOSByteArray *DECODABET = [FFTBase64 getDecodabetWithInt:options];
  if (IOSByteArray_Get(nil_chk(source), srcOffset + 2) == FFTBase64_EQUALS_SIGN) {
    int outBuff = ((IOSByteArray_Get(nil_chk(DECODABET), IOSByteArray_Get(source, srcOffset)) & (int) 0xFF) << 18) | ((IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 1)) & (int) 0xFF) << 12);
    (*IOSByteArray_GetRef(nil_chk(destination), destOffset)) = (char) ((int) (((unsigned int) outBuff) >> 16));
    return 1;
  }
  else if (IOSByteArray_Get(source, srcOffset + 3) == FFTBase64_EQUALS_SIGN) {
    int outBuff = ((IOSByteArray_Get(nil_chk(DECODABET), IOSByteArray_Get(source, srcOffset)) & (int) 0xFF) << 18) | ((IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 1)) & (int) 0xFF) << 12) | ((IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 2)) & (int) 0xFF) << 6);
    (*IOSByteArray_GetRef(nil_chk(destination), destOffset)) = (char) ((int) (((unsigned int) outBuff) >> 16));
    (*IOSByteArray_GetRef(destination, destOffset + 1)) = (char) ((int) (((unsigned int) outBuff) >> 8));
    return 2;
  }
  else {
    int outBuff = ((IOSByteArray_Get(nil_chk(DECODABET), IOSByteArray_Get(source, srcOffset)) & (int) 0xFF) << 18) | ((IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 1)) & (int) 0xFF) << 12) | ((IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 2)) & (int) 0xFF) << 6) | ((IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 3)) & (int) 0xFF));
    (*IOSByteArray_GetRef(nil_chk(destination), destOffset)) = (char) (outBuff >> 16);
    (*IOSByteArray_GetRef(destination, destOffset + 1)) = (char) (outBuff >> 8);
    (*IOSByteArray_GetRef(destination, destOffset + 2)) = (char) (outBuff);
    return 3;
  }
}

+ (IOSByteArray *)decodeWithByteArray:(IOSByteArray *)source {
  IOSByteArray *decoded = nil;
  decoded = [FFTBase64 decodeWithByteArray:source withInt:0 withInt:(int) [((IOSByteArray *) nil_chk(source)) count] withInt:FFTBase64_NO_OPTIONS];
  return decoded;
}

+ (IOSByteArray *)decodeWithByteArray:(IOSByteArray *)source
                              withInt:(int)off
                              withInt:(int)len
                              withInt:(int)options {
  if (source == nil) {
    @throw [[JavaLangNullPointerException alloc] initWithNSString:@"Cannot decode null source array."];
  }
  if (off < 0 || off + len > (int) [((IOSByteArray *) nil_chk(source)) count]) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:[NSString formatWithNSString:@"Source array with length %d cannot have offset of %d and process %d bytes." withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ [JavaLangInteger valueOfWithInt:(int) [((IOSByteArray *) nil_chk(source)) count]], [JavaLangInteger valueOfWithInt:off], [JavaLangInteger valueOfWithInt:len] } count:3 type:[IOSClass classWithClass:[NSObject class]]]]];
  }
  if (len == 0) {
    return [IOSByteArray arrayWithLength:0];
  }
  else if (len < 4) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:[NSString stringWithFormat:@"Base64-encoded string must have at least four characters, but length specified was %d", len]];
  }
  IOSByteArray *DECODABET = [FFTBase64 getDecodabetWithInt:options];
  int len34 = len * 3 / 4;
  IOSByteArray *outBuff = [IOSByteArray arrayWithLength:len34];
  int outBuffPosn = 0;
  IOSByteArray *b4 = [IOSByteArray arrayWithLength:4];
  int b4Posn = 0;
  int i = 0;
  char sbiDecode = 0;
  for (i = off; i < off + len; i++) {
    sbiDecode = IOSByteArray_Get(nil_chk(DECODABET), IOSByteArray_Get(nil_chk(source), i) & (int) 0xFF);
    if (sbiDecode >= FFTBase64_WHITE_SPACE_ENC) {
      if (sbiDecode >= FFTBase64_EQUALS_SIGN_ENC) {
        (*IOSByteArray_GetRef(b4, b4Posn++)) = IOSByteArray_Get(source, i);
        if (b4Posn > 3) {
          outBuffPosn += [FFTBase64 decode4to3WithByteArray:b4 withInt:0 withByteArray:outBuff withInt:outBuffPosn withInt:options];
          b4Posn = 0;
          if (IOSByteArray_Get(source, i) == FFTBase64_EQUALS_SIGN) {
            break;
          }
        }
      }
    }
    else {
      @throw [[JavaIoIOException alloc] initWithNSString:[NSString formatWithNSString:@"Bad Base64 input character decimal %d in array position %d" withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ [JavaLangInteger valueOfWithInt:(IOSByteArray_Get(source, i)) & (int) 0xFF], [JavaLangInteger valueOfWithInt:i] } count:2 type:[IOSClass classWithClass:[NSObject class]]]]];
    }
  }
  IOSByteArray *out = [IOSByteArray arrayWithLength:outBuffPosn];
  [JavaLangSystem arraycopyWithId:outBuff withInt:0 withId:out withInt:0 withInt:outBuffPosn];
  return out;
}

+ (IOSByteArray *)decodeWithNSString:(NSString *)s {
  return [FFTBase64 decodeWithNSString:s withInt:FFTBase64_NO_OPTIONS];
}

+ (IOSByteArray *)decodeWithNSString:(NSString *)s
                             withInt:(int)options {
  if (s == nil) {
    @throw [[JavaLangNullPointerException alloc] initWithNSString:@"Input string was null."];
  }
  IOSByteArray *bytes;
  @try {
    bytes = [((NSString *) nil_chk(s)) getBytesWithCharsetName:FFTBase64_PREFERRED_ENCODING_];
  }
  @catch (JavaIoUnsupportedEncodingException *uee) {
    bytes = [((NSString *) nil_chk(s)) getBytes];
  }
  bytes = [FFTBase64 decodeWithByteArray:bytes withInt:0 withInt:(int) [((IOSByteArray *) nil_chk(bytes)) count] withInt:options];
  BOOL dontGunzip = (options & FFTBase64_DONT_GUNZIP) != 0;
  if ((bytes != nil) && ((int) [bytes count] >= 4) && (!dontGunzip)) {
    int head = (IOSByteArray_Get(bytes, 0) & (int) 0xff) | ((IOSByteArray_Get(bytes, 1) << 8) & (int) 0xff00);
    if (JavaUtilZipGZIPInputStream_GZIP_MAGIC == head) {
      JavaIoByteArrayInputStream *bais = nil;
      JavaUtilZipGZIPInputStream *gzis = nil;
      JavaIoByteArrayOutputStream *baos = nil;
      IOSByteArray *buffer = [IOSByteArray arrayWithLength:2048];
      int length = 0;
      @try {
        baos = [[JavaIoByteArrayOutputStream alloc] init];
        bais = [[JavaIoByteArrayInputStream alloc] initWithByteArray:bytes];
        gzis = [[JavaUtilZipGZIPInputStream alloc] initWithJavaIoInputStream:bais];
        while ((length = [gzis readWithByteArray:buffer]) >= 0) {
          [baos writeWithByteArray:buffer withInt:0 withInt:length];
        }
        bytes = [baos toByteArray];
      }
      @catch (JavaIoIOException *e) {
        [((JavaIoIOException *) nil_chk(e)) printStackTrace];
      }
      @finally {
        @try {
          [((JavaIoByteArrayOutputStream *) nil_chk(baos)) close];
        }
        @catch (JavaLangException *e) {
        }
        @try {
          [((JavaUtilZipGZIPInputStream *) nil_chk(gzis)) close];
        }
        @catch (JavaLangException *e) {
        }
        @try {
          [((JavaIoByteArrayInputStream *) nil_chk(bais)) close];
        }
        @catch (JavaLangException *e) {
        }
      }
    }
  }
  return bytes;
}

+ (id)decodeToObjectWithNSString:(NSString *)encodedObject {
  return [FFTBase64 decodeToObjectWithNSString:encodedObject withInt:FFTBase64_NO_OPTIONS withJavaLangClassLoader:nil];
}

+ (id)decodeToObjectWithNSString:(NSString *)encodedObject
                         withInt:(int)options
         withJavaLangClassLoader:(JavaLangClassLoader *)loader {
  IOSByteArray *objBytes = [FFTBase64 decodeWithNSString:encodedObject withInt:options];
  JavaIoByteArrayInputStream *bais = nil;
  JavaIoObjectInputStream *ois = nil;
  id obj = nil;
  @try {
    bais = [[JavaIoByteArrayInputStream alloc] initWithByteArray:objBytes];
    if (loader == nil) {
      ois = [[JavaIoObjectInputStream alloc] initWithJavaIoInputStream:bais];
    }
    else {
      ois = [[FFTBase64_$1 alloc] initWithJavaIoByteArrayInputStream:bais withJavaLangClassLoader:loader];
    }
    obj = [((JavaIoObjectInputStream *) nil_chk(ois)) readObject];
  }
  @catch (JavaIoIOException *e) {
    @throw e;
  }
  @catch (JavaLangClassNotFoundException *e) {
    @throw e;
  }
  @finally {
    @try {
      [((JavaIoByteArrayInputStream *) nil_chk(bais)) close];
    }
    @catch (JavaLangException *e) {
    }
    @try {
      [((JavaIoObjectInputStream *) nil_chk(ois)) close];
    }
    @catch (JavaLangException *e) {
    }
  }
  return obj;
}

+ (void)encodeToFileWithByteArray:(IOSByteArray *)dataToEncode
                     withNSString:(NSString *)filename {
  if (dataToEncode == nil) {
    @throw [[JavaLangNullPointerException alloc] initWithNSString:@"Data to encode was null."];
  }
  FFTBase64_OutputStream *bos = nil;
  @try {
    bos = [[FFTBase64_OutputStream alloc] initWithJavaIoOutputStream:[[JavaIoFileOutputStream alloc] initWithNSString:filename] withInt:FFTBase64_ENCODE];
    [bos writeWithByteArray:dataToEncode];
  }
  @catch (JavaIoIOException *e) {
    @throw e;
  }
  @finally {
    @try {
      [((FFTBase64_OutputStream *) nil_chk(bos)) close];
    }
    @catch (JavaLangException *e) {
    }
  }
}

+ (void)decodeToFileWithNSString:(NSString *)dataToDecode
                    withNSString:(NSString *)filename {
  FFTBase64_OutputStream *bos = nil;
  @try {
    bos = [[FFTBase64_OutputStream alloc] initWithJavaIoOutputStream:[[JavaIoFileOutputStream alloc] initWithNSString:filename] withInt:FFTBase64_DECODE];
    [bos writeWithByteArray:[((NSString *) nil_chk(dataToDecode)) getBytesWithCharsetName:FFTBase64_PREFERRED_ENCODING_]];
  }
  @catch (JavaIoIOException *e) {
    @throw e;
  }
  @finally {
    @try {
      [((FFTBase64_OutputStream *) nil_chk(bos)) close];
    }
    @catch (JavaLangException *e) {
    }
  }
}

+ (IOSByteArray *)decodeFromFileWithNSString:(NSString *)filename {
  IOSByteArray *decodedData = nil;
  FFTBase64_InputStream *bis = nil;
  @try {
    JavaIoFile *file = [[JavaIoFile alloc] initWithNSString:filename];
    IOSByteArray *buffer = nil;
    int length = 0;
    int numBytes = 0;
    if ([file length] > JavaLangInteger_MAX_VALUE) {
      @throw [[JavaIoIOException alloc] initWithNSString:[NSString stringWithFormat:@"File is too big for this convenience method (%lld bytes).", [file length]]];
    }
    buffer = [IOSByteArray arrayWithLength:(int) [file length]];
    bis = [[FFTBase64_InputStream alloc] initWithJavaIoInputStream:[[JavaIoBufferedInputStream alloc] initWithJavaIoInputStream:[[JavaIoFileInputStream alloc] initWithJavaIoFile:file]] withInt:FFTBase64_DECODE];
    while ((numBytes = [bis readWithByteArray:buffer withInt:length withInt:4096]) >= 0) {
      length += numBytes;
    }
    decodedData = [IOSByteArray arrayWithLength:length];
    [JavaLangSystem arraycopyWithId:buffer withInt:0 withId:decodedData withInt:0 withInt:length];
  }
  @catch (JavaIoIOException *e) {
    @throw e;
  }
  @finally {
    @try {
      [((FFTBase64_InputStream *) nil_chk(bis)) close];
    }
    @catch (JavaLangException *e) {
    }
  }
  return decodedData;
}

+ (NSString *)encodeFromFileWithNSString:(NSString *)filename {
  NSString *encodedData = nil;
  FFTBase64_InputStream *bis = nil;
  @try {
    JavaIoFile *file = [[JavaIoFile alloc] initWithNSString:filename];
    IOSByteArray *buffer = [IOSByteArray arrayWithLength:[JavaLangMath maxWithInt:J2ObjCFpToInt(([file length] * 1.4 + 1)) withInt:40]];
    int length = 0;
    int numBytes = 0;
    bis = [[FFTBase64_InputStream alloc] initWithJavaIoInputStream:[[JavaIoBufferedInputStream alloc] initWithJavaIoInputStream:[[JavaIoFileInputStream alloc] initWithJavaIoFile:file]] withInt:FFTBase64_ENCODE];
    while ((numBytes = [bis readWithByteArray:buffer withInt:length withInt:4096]) >= 0) {
      length += numBytes;
    }
    encodedData = [NSString stringWithBytes:buffer offset:0 length:length charsetName:FFTBase64_PREFERRED_ENCODING_];
  }
  @catch (JavaIoIOException *e) {
    @throw e;
  }
  @finally {
    @try {
      [((FFTBase64_InputStream *) nil_chk(bis)) close];
    }
    @catch (JavaLangException *e) {
    }
  }
  return encodedData;
}

+ (void)encodeFileToFileWithNSString:(NSString *)infile
                        withNSString:(NSString *)outfile {
  NSString *encoded = [FFTBase64 encodeFromFileWithNSString:infile];
  JavaIoOutputStream *out = nil;
  @try {
    out = [[JavaIoBufferedOutputStream alloc] initWithJavaIoOutputStream:[[JavaIoFileOutputStream alloc] initWithNSString:outfile]];
    [out writeWithByteArray:[((NSString *) nil_chk(encoded)) getBytesWithCharsetName:@"US-ASCII"]];
  }
  @catch (JavaIoIOException *e) {
    @throw e;
  }
  @finally {
    @try {
      [((JavaIoOutputStream *) nil_chk(out)) close];
    }
    @catch (JavaLangException *ex) {
    }
  }
}

+ (void)decodeFileToFileWithNSString:(NSString *)infile
                        withNSString:(NSString *)outfile {
  IOSByteArray *decoded = [FFTBase64 decodeFromFileWithNSString:infile];
  JavaIoOutputStream *out = nil;
  @try {
    out = [[JavaIoBufferedOutputStream alloc] initWithJavaIoOutputStream:[[JavaIoFileOutputStream alloc] initWithNSString:outfile]];
    [out writeWithByteArray:decoded];
  }
  @catch (JavaIoIOException *e) {
    @throw e;
  }
  @finally {
    @try {
      [((JavaIoOutputStream *) nil_chk(out)) close];
    }
    @catch (JavaLangException *ex) {
    }
  }
}

+ (void)initialize {
  if (self == [FFTBase64 class]) {
    FFTBase64__STANDARD_ALPHABET_ = [IOSByteArray arrayWithBytes:(char[]){ (char) 'A', (char) 'B', (char) 'C', (char) 'D', (char) 'E', (char) 'F', (char) 'G', (char) 'H', (char) 'I', (char) 'J', (char) 'K', (char) 'L', (char) 'M', (char) 'N', (char) 'O', (char) 'P', (char) 'Q', (char) 'R', (char) 'S', (char) 'T', (char) 'U', (char) 'V', (char) 'W', (char) 'X', (char) 'Y', (char) 'Z', (char) 'a', (char) 'b', (char) 'c', (char) 'd', (char) 'e', (char) 'f', (char) 'g', (char) 'h', (char) 'i', (char) 'j', (char) 'k', (char) 'l', (char) 'm', (char) 'n', (char) 'o', (char) 'p', (char) 'q', (char) 'r', (char) 's', (char) 't', (char) 'u', (char) 'v', (char) 'w', (char) 'x', (char) 'y', (char) 'z', (char) '0', (char) '1', (char) '2', (char) '3', (char) '4', (char) '5', (char) '6', (char) '7', (char) '8', (char) '9', (char) '+', (char) '/' } count:64];
    FFTBase64__STANDARD_DECODABET_ = [IOSByteArray arrayWithBytes:(char[]){ -9, -9, -9, -9, -9, -9, -9, -9, -9, -5, -5, -9, -9, -5, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -5, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, 62, -9, -9, -9, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -9, -9, -9, -1, -9, -9, -9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -9, -9, -9, -9, -9, -9, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9 } count:256];
    FFTBase64__URL_SAFE_ALPHABET_ = [IOSByteArray arrayWithBytes:(char[]){ (char) 'A', (char) 'B', (char) 'C', (char) 'D', (char) 'E', (char) 'F', (char) 'G', (char) 'H', (char) 'I', (char) 'J', (char) 'K', (char) 'L', (char) 'M', (char) 'N', (char) 'O', (char) 'P', (char) 'Q', (char) 'R', (char) 'S', (char) 'T', (char) 'U', (char) 'V', (char) 'W', (char) 'X', (char) 'Y', (char) 'Z', (char) 'a', (char) 'b', (char) 'c', (char) 'd', (char) 'e', (char) 'f', (char) 'g', (char) 'h', (char) 'i', (char) 'j', (char) 'k', (char) 'l', (char) 'm', (char) 'n', (char) 'o', (char) 'p', (char) 'q', (char) 'r', (char) 's', (char) 't', (char) 'u', (char) 'v', (char) 'w', (char) 'x', (char) 'y', (char) 'z', (char) '0', (char) '1', (char) '2', (char) '3', (char) '4', (char) '5', (char) '6', (char) '7', (char) '8', (char) '9', (char) '-', (char) '_' } count:64];
    FFTBase64__URL_SAFE_DECODABET_ = [IOSByteArray arrayWithBytes:(char[]){ -9, -9, -9, -9, -9, -9, -9, -9, -9, -5, -5, -9, -9, -5, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -5, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, 62, -9, -9, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -9, -9, -9, -1, -9, -9, -9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -9, -9, -9, -9, 63, -9, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9 } count:256];
    FFTBase64__ORDERED_ALPHABET_ = [IOSByteArray arrayWithBytes:(char[]){ (char) '-', (char) '0', (char) '1', (char) '2', (char) '3', (char) '4', (char) '5', (char) '6', (char) '7', (char) '8', (char) '9', (char) 'A', (char) 'B', (char) 'C', (char) 'D', (char) 'E', (char) 'F', (char) 'G', (char) 'H', (char) 'I', (char) 'J', (char) 'K', (char) 'L', (char) 'M', (char) 'N', (char) 'O', (char) 'P', (char) 'Q', (char) 'R', (char) 'S', (char) 'T', (char) 'U', (char) 'V', (char) 'W', (char) 'X', (char) 'Y', (char) 'Z', (char) '_', (char) 'a', (char) 'b', (char) 'c', (char) 'd', (char) 'e', (char) 'f', (char) 'g', (char) 'h', (char) 'i', (char) 'j', (char) 'k', (char) 'l', (char) 'm', (char) 'n', (char) 'o', (char) 'p', (char) 'q', (char) 'r', (char) 's', (char) 't', (char) 'u', (char) 'v', (char) 'w', (char) 'x', (char) 'y', (char) 'z' } count:64];
    FFTBase64__ORDERED_DECODABET_ = [IOSByteArray arrayWithBytes:(char[]){ -9, -9, -9, -9, -9, -9, -9, -9, -9, -5, -5, -9, -9, -5, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -5, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, 0, -9, -9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -9, -9, -9, -1, -9, -9, -9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, -9, -9, -9, -9, 37, -9, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9 } count:257];
    FFTBase64_initialized = YES;
  }
}

+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "getAlphabetWithInt:", "getAlphabet", "[B", 0x1a, NULL },
    { "getDecodabetWithInt:", "getDecodabet", "[B", 0x1a, NULL },
    { "init", "Base64", NULL, 0x2, NULL },
    { "encode3to4WithByteArray:withByteArray:withInt:withInt:", "encode3to4", "[B", 0xa, NULL },
    { "encode3to4WithByteArray:withInt:withInt:withByteArray:withInt:withInt:", "encode3to4", "[B", 0xa, NULL },
    { "encodeWithJavaNioByteBuffer:withJavaNioByteBuffer:", "encode", "V", 0x9, NULL },
    { "encodeWithJavaNioByteBuffer:withJavaNioCharBuffer:", "encode", "V", 0x9, NULL },
    { "encodeObjectWithJavaIoSerializable:", "encodeObject", "Ljava.lang.String;", 0x9, "Ljava.io.IOException;" },
    { "encodeObjectWithJavaIoSerializable:withInt:", "encodeObject", "Ljava.lang.String;", 0x9, "Ljava.io.IOException;" },
    { "encodeBytesWithByteArray:", "encodeBytes", "Ljava.lang.String;", 0x9, NULL },
    { "encodeBytesWithByteArray:withInt:", "encodeBytes", "Ljava.lang.String;", 0x9, "Ljava.io.IOException;" },
    { "encodeBytesWithByteArray:withInt:withInt:", "encodeBytes", "Ljava.lang.String;", 0x9, NULL },
    { "encodeBytesWithByteArray:withInt:withInt:withInt:", "encodeBytes", "Ljava.lang.String;", 0x9, "Ljava.io.IOException;" },
    { "encodeBytesToBytesWithByteArray:", "encodeBytesToBytes", "[B", 0x9, NULL },
    { "encodeBytesToBytesWithByteArray:withInt:withInt:withInt:", "encodeBytesToBytes", "[B", 0x9, "Ljava.io.IOException;" },
    { "decode4to3WithByteArray:withInt:withByteArray:withInt:withInt:", "decode4to3", "I", 0xa, NULL },
    { "decodeWithByteArray:", "decode", "[B", 0x9, "Ljava.io.IOException;" },
    { "decodeWithByteArray:withInt:withInt:withInt:", "decode", "[B", 0x9, "Ljava.io.IOException;" },
    { "decodeWithNSString:", "decode", "[B", 0x9, "Ljava.io.IOException;" },
    { "decodeWithNSString:withInt:", "decode", "[B", 0x9, "Ljava.io.IOException;" },
    { "decodeToObjectWithNSString:", "decodeToObject", "Ljava.lang.Object;", 0x9, "Ljava.io.IOException;Ljava.lang.ClassNotFoundException;" },
    { "decodeToObjectWithNSString:withInt:withJavaLangClassLoader:", "decodeToObject", "Ljava.lang.Object;", 0x9, "Ljava.io.IOException;Ljava.lang.ClassNotFoundException;" },
    { "encodeToFileWithByteArray:withNSString:", "encodeToFile", "V", 0x9, "Ljava.io.IOException;" },
    { "decodeToFileWithNSString:withNSString:", "decodeToFile", "V", 0x9, "Ljava.io.IOException;" },
    { "decodeFromFileWithNSString:", "decodeFromFile", "[B", 0x9, "Ljava.io.IOException;" },
    { "encodeFromFileWithNSString:", "encodeFromFile", "Ljava.lang.String;", 0x9, "Ljava.io.IOException;" },
    { "encodeFileToFileWithNSString:withNSString:", "encodeFileToFile", "V", 0x9, "Ljava.io.IOException;" },
    { "decodeFileToFileWithNSString:withNSString:", "decodeFileToFile", "V", 0x9, "Ljava.io.IOException;" },
  };
  static J2ObjcFieldInfo fields[] = {
    { "NO_OPTIONS_", NULL, 0x19, "I", NULL, .constantValue.asInt = FFTBase64_NO_OPTIONS },
    { "ENCODE_", NULL, 0x19, "I", NULL, .constantValue.asInt = FFTBase64_ENCODE },
    { "DECODE_", NULL, 0x19, "I", NULL, .constantValue.asInt = FFTBase64_DECODE },
    { "GZIP_", NULL, 0x19, "I", NULL, .constantValue.asInt = FFTBase64_GZIP },
    { "DONT_GUNZIP_", NULL, 0x19, "I", NULL, .constantValue.asInt = FFTBase64_DONT_GUNZIP },
    { "DO_BREAK_LINES_", NULL, 0x19, "I", NULL, .constantValue.asInt = FFTBase64_DO_BREAK_LINES },
    { "URL_SAFE_", NULL, 0x19, "I", NULL, .constantValue.asInt = FFTBase64_URL_SAFE },
    { "ORDERED_", NULL, 0x19, "I", NULL, .constantValue.asInt = FFTBase64_ORDERED },
    { "MAX_LINE_LENGTH_", NULL, 0x1a, "I", NULL, .constantValue.asInt = FFTBase64_MAX_LINE_LENGTH },
    { "EQUALS_SIGN_", NULL, 0x1a, "B", NULL, .constantValue.asChar = FFTBase64_EQUALS_SIGN },
    { "NEW_LINE_", NULL, 0x1a, "B", NULL, .constantValue.asChar = FFTBase64_NEW_LINE },
    { "PREFERRED_ENCODING_", NULL, 0x1a, "Ljava.lang.String;", &FFTBase64_PREFERRED_ENCODING_,  },
    { "WHITE_SPACE_ENC_", NULL, 0x1a, "B", NULL, .constantValue.asChar = FFTBase64_WHITE_SPACE_ENC },
    { "EQUALS_SIGN_ENC_", NULL, 0x1a, "B", NULL, .constantValue.asChar = FFTBase64_EQUALS_SIGN_ENC },
    { "_STANDARD_ALPHABET_", NULL, 0x1a, "[B", &FFTBase64__STANDARD_ALPHABET_,  },
    { "_STANDARD_DECODABET_", NULL, 0x1a, "[B", &FFTBase64__STANDARD_DECODABET_,  },
    { "_URL_SAFE_ALPHABET_", NULL, 0x1a, "[B", &FFTBase64__URL_SAFE_ALPHABET_,  },
    { "_URL_SAFE_DECODABET_", NULL, 0x1a, "[B", &FFTBase64__URL_SAFE_DECODABET_,  },
    { "_ORDERED_ALPHABET_", NULL, 0x1a, "[B", &FFTBase64__ORDERED_ALPHABET_,  },
    { "_ORDERED_DECODABET_", NULL, 0x1a, "[B", &FFTBase64__ORDERED_DECODABET_,  },
  };
  static J2ObjcClassInfo _FFTBase64 = { "Base64", "com.sponberg.fluid.util", NULL, 0x1, 28, methods, 20, fields, 0, NULL};
  return &_FFTBase64;
}

@end

@implementation FFTBase64_InputStream

- (id)initWithJavaIoInputStream:(JavaIoInputStream *)inArg {
  return [self initFFTBase64_InputStreamWithJavaIoInputStream:inArg withInt:FFTBase64_DECODE];
}

- (id)initFFTBase64_InputStreamWithJavaIoInputStream:(JavaIoInputStream *)inArg
                                             withInt:(int)options {
  if (self = [super initWithJavaIoInputStream:inArg]) {
    self->options_ = options;
    self->breakLines_ = (options & FFTBase64_DO_BREAK_LINES) > 0;
    self->encode_ = (options & FFTBase64_ENCODE) > 0;
    self->bufferLength_ = encode_ ? 4 : 3;
    self->buffer_ = [IOSByteArray arrayWithLength:bufferLength_];
    self->position_ = -1;
    self->lineLength_ = 0;
    self->decodabet_ = [FFTBase64 getDecodabetWithInt:options];
  }
  return self;
}

- (id)initWithJavaIoInputStream:(JavaIoInputStream *)inArg
                        withInt:(int)options {
  return [self initFFTBase64_InputStreamWithJavaIoInputStream:inArg withInt:options];
}

- (int)read {
  if (position_ < 0) {
    if (encode_) {
      IOSByteArray *b3 = [IOSByteArray arrayWithLength:3];
      int numBinaryBytes = 0;
      for (int i = 0; i < 3; i++) {
        int b = [((JavaIoInputStream *) nil_chk(in_)) read];
        if (b >= 0) {
          (*IOSByteArray_GetRef(b3, i)) = (char) b;
          numBinaryBytes++;
        }
        else {
          break;
        }
      }
      if (numBinaryBytes > 0) {
        (void) [FFTBase64 encode3to4WithByteArray:b3 withInt:0 withInt:numBinaryBytes withByteArray:buffer_ withInt:0 withInt:options_];
        position_ = 0;
        numSigBytes_ = 4;
      }
      else {
        return -1;
      }
    }
    else {
      IOSByteArray *b4 = [IOSByteArray arrayWithLength:4];
      int i = 0;
      for (i = 0; i < 4; i++) {
        int b = 0;
        do {
          b = [((JavaIoInputStream *) nil_chk(in_)) read];
        }
        while (b >= 0 && IOSByteArray_Get(nil_chk(decodabet_), b & (int) 0x7f) <= FFTBase64_WHITE_SPACE_ENC);
        if (b < 0) {
          break;
        }
        (*IOSByteArray_GetRef(b4, i)) = (char) b;
      }
      if (i == 4) {
        numSigBytes_ = [FFTBase64 decode4to3WithByteArray:b4 withInt:0 withByteArray:buffer_ withInt:0 withInt:options_];
        position_ = 0;
      }
      else if (i == 0) {
        return -1;
      }
      else {
        @throw [[JavaIoIOException alloc] initWithNSString:@"Improperly padded Base64 input."];
      }
    }
  }
  if (position_ >= 0) {
    if (position_ >= numSigBytes_) {
      return -1;
    }
    if (encode_ && breakLines_ && lineLength_ >= FFTBase64_MAX_LINE_LENGTH) {
      lineLength_ = 0;
      return 0x000a;
    }
    else {
      lineLength_++;
      int b = IOSByteArray_Get(nil_chk(buffer_), position_++);
      if (position_ >= bufferLength_) {
        position_ = -1;
      }
      return b & (int) 0xFF;
    }
  }
  else {
    @throw [[JavaIoIOException alloc] initWithNSString:@"Error in Base64 code reading stream."];
  }
}

- (int)readWithByteArray:(IOSByteArray *)dest
                 withInt:(int)off
                 withInt:(int)len {
  int i;
  int b;
  for (i = 0; i < len; i++) {
    b = [self read];
    if (b >= 0) {
      (*IOSByteArray_GetRef(nil_chk(dest), off + i)) = (char) b;
    }
    else if (i == 0) {
      return -1;
    }
    else {
      break;
    }
  }
  return i;
}

- (void)copyAllFieldsTo:(FFTBase64_InputStream *)other {
  [super copyAllFieldsTo:other];
  other->breakLines_ = breakLines_;
  other->buffer_ = buffer_;
  other->bufferLength_ = bufferLength_;
  other->decodabet_ = decodabet_;
  other->encode_ = encode_;
  other->lineLength_ = lineLength_;
  other->numSigBytes_ = numSigBytes_;
  other->options_ = options_;
  other->position_ = position_;
}

+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "initWithJavaIoInputStream:", "InputStream", NULL, 0x1, NULL },
    { "initWithJavaIoInputStream:withInt:", "InputStream", NULL, 0x1, NULL },
    { "read", NULL, "I", 0x1, "Ljava.io.IOException;" },
    { "readWithByteArray:withInt:withInt:", "read", "I", 0x1, "Ljava.io.IOException;" },
  };
  static J2ObjcFieldInfo fields[] = {
    { "encode_", NULL, 0x12, "Z", NULL,  },
    { "position_", NULL, 0x2, "I", NULL,  },
    { "buffer_", NULL, 0x12, "[B", NULL,  },
    { "bufferLength_", NULL, 0x12, "I", NULL,  },
    { "numSigBytes_", NULL, 0x2, "I", NULL,  },
    { "lineLength_", NULL, 0x2, "I", NULL,  },
    { "breakLines_", NULL, 0x12, "Z", NULL,  },
    { "options_", NULL, 0x12, "I", NULL,  },
    { "decodabet_", NULL, 0x12, "[B", NULL,  },
  };
  static J2ObjcClassInfo _FFTBase64_InputStream = { "InputStream", "com.sponberg.fluid.util", "Base64", 0x9, 4, methods, 9, fields, 0, NULL};
  return &_FFTBase64_InputStream;
}

@end

@implementation FFTBase64_OutputStream

- (id)initWithJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  return [self initFFTBase64_OutputStreamWithJavaIoOutputStream:outArg withInt:FFTBase64_ENCODE];
}

- (id)initFFTBase64_OutputStreamWithJavaIoOutputStream:(JavaIoOutputStream *)outArg
                                               withInt:(int)options {
  if (self = [super initWithJavaIoOutputStream:outArg]) {
    self->breakLines_ = (options & FFTBase64_DO_BREAK_LINES) != 0;
    self->encode_ = (options & FFTBase64_ENCODE) != 0;
    self->bufferLength_ = encode_ ? 3 : 4;
    self->buffer_ = [IOSByteArray arrayWithLength:bufferLength_];
    self->position_ = 0;
    self->lineLength_ = 0;
    self->suspendEncoding__ = NO;
    self->b4_ = [IOSByteArray arrayWithLength:4];
    self->options_ = options;
    self->decodabet_ = [FFTBase64 getDecodabetWithInt:options];
  }
  return self;
}

- (id)initWithJavaIoOutputStream:(JavaIoOutputStream *)outArg
                         withInt:(int)options {
  return [self initFFTBase64_OutputStreamWithJavaIoOutputStream:outArg withInt:options];
}

- (void)writeWithInt:(int)theByte {
  if (suspendEncoding__) {
    [((JavaIoOutputStream *) nil_chk(self->out_)) writeWithInt:theByte];
    return;
  }
  if (encode_) {
    (*IOSByteArray_GetRef(nil_chk(buffer_), position_++)) = (char) theByte;
    if (position_ >= bufferLength_) {
      [((JavaIoOutputStream *) nil_chk(self->out_)) writeWithByteArray:[FFTBase64 encode3to4WithByteArray:b4_ withByteArray:buffer_ withInt:bufferLength_ withInt:options_]];
      lineLength_ += 4;
      if (breakLines_ && lineLength_ >= FFTBase64_MAX_LINE_LENGTH) {
        [self->out_ writeWithInt:FFTBase64_NEW_LINE];
        lineLength_ = 0;
      }
      position_ = 0;
    }
  }
  else {
    if (IOSByteArray_Get(nil_chk(decodabet_), theByte & (int) 0x7f) > FFTBase64_WHITE_SPACE_ENC) {
      (*IOSByteArray_GetRef(nil_chk(buffer_), position_++)) = (char) theByte;
      if (position_ >= bufferLength_) {
        int len = [FFTBase64 decode4to3WithByteArray:buffer_ withInt:0 withByteArray:b4_ withInt:0 withInt:options_];
        [((JavaIoOutputStream *) nil_chk(out_)) writeWithByteArray:b4_ withInt:0 withInt:len];
        position_ = 0;
      }
    }
    else if (IOSByteArray_Get(decodabet_, theByte & (int) 0x7f) != FFTBase64_WHITE_SPACE_ENC) {
      @throw [[JavaIoIOException alloc] initWithNSString:@"Invalid character in Base64 data."];
    }
  }
}

- (void)writeWithByteArray:(IOSByteArray *)theBytes
                   withInt:(int)off
                   withInt:(int)len {
  if (suspendEncoding__) {
    [((JavaIoOutputStream *) nil_chk(self->out_)) writeWithByteArray:theBytes withInt:off withInt:len];
    return;
  }
  for (int i = 0; i < len; i++) {
    [self writeWithInt:IOSByteArray_Get(nil_chk(theBytes), off + i)];
  }
}

- (void)flushBase64 {
  if (position_ > 0) {
    if (encode_) {
      [((JavaIoOutputStream *) nil_chk(out_)) writeWithByteArray:[FFTBase64 encode3to4WithByteArray:b4_ withByteArray:buffer_ withInt:position_ withInt:options_]];
      position_ = 0;
    }
    else {
      @throw [[JavaIoIOException alloc] initWithNSString:@"Base64 input not properly padded."];
    }
  }
}

- (void)close {
  [self flushBase64];
  [super close];
  buffer_ = nil;
  out_ = nil;
}

- (void)suspendEncoding {
  [self flushBase64];
  self->suspendEncoding__ = YES;
}

- (void)resumeEncoding {
  self->suspendEncoding__ = NO;
}

- (void)copyAllFieldsTo:(FFTBase64_OutputStream *)other {
  [super copyAllFieldsTo:other];
  other->b4_ = b4_;
  other->breakLines_ = breakLines_;
  other->buffer_ = buffer_;
  other->bufferLength_ = bufferLength_;
  other->decodabet_ = decodabet_;
  other->encode_ = encode_;
  other->lineLength_ = lineLength_;
  other->options_ = options_;
  other->position_ = position_;
  other->suspendEncoding__ = suspendEncoding__;
}

+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "initWithJavaIoOutputStream:", "OutputStream", NULL, 0x1, NULL },
    { "initWithJavaIoOutputStream:withInt:", "OutputStream", NULL, 0x1, NULL },
    { "writeWithInt:", "write", "V", 0x1, "Ljava.io.IOException;" },
    { "writeWithByteArray:withInt:withInt:", "write", "V", 0x1, "Ljava.io.IOException;" },
    { "flushBase64", NULL, "V", 0x1, "Ljava.io.IOException;" },
    { "close", NULL, "V", 0x1, "Ljava.io.IOException;" },
    { "suspendEncoding", NULL, "V", 0x1, "Ljava.io.IOException;" },
    { "resumeEncoding", NULL, "V", 0x1, NULL },
  };
  static J2ObjcFieldInfo fields[] = {
    { "encode_", NULL, 0x12, "Z", NULL,  },
    { "position_", NULL, 0x2, "I", NULL,  },
    { "buffer_", NULL, 0x2, "[B", NULL,  },
    { "bufferLength_", NULL, 0x12, "I", NULL,  },
    { "lineLength_", NULL, 0x2, "I", NULL,  },
    { "breakLines_", NULL, 0x12, "Z", NULL,  },
    { "b4_", NULL, 0x12, "[B", NULL,  },
    { "suspendEncoding__", "suspendEncoding", 0x2, "Z", NULL,  },
    { "options_", NULL, 0x12, "I", NULL,  },
    { "decodabet_", NULL, 0x12, "[B", NULL,  },
  };
  static J2ObjcClassInfo _FFTBase64_OutputStream = { "OutputStream", "com.sponberg.fluid.util", "Base64", 0x9, 8, methods, 10, fields, 0, NULL};
  return &_FFTBase64_OutputStream;
}

@end

@implementation FFTBase64_$1

- (IOSClass *)resolveClassWithJavaIoObjectStreamClass:(JavaIoObjectStreamClass *)streamClass {
  IOSClass *c = [IOSClass forName:[((JavaIoObjectStreamClass *) nil_chk(streamClass)) getName] initialize:NO classLoader:val$loader_];
  if (c == nil) {
    return [super resolveClassWithJavaIoObjectStreamClass:streamClass];
  }
  else {
    return c;
  }
}

- (id)initWithJavaIoByteArrayInputStream:(JavaIoByteArrayInputStream *)arg$0
                 withJavaLangClassLoader:(JavaLangClassLoader *)capture$0 {
  val$loader_ = capture$0;
  return [super initWithJavaIoInputStream:arg$0];
}

+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "resolveClassWithJavaIoObjectStreamClass:", "resolveClass", "Ljava.lang.Class;", 0x1, "Ljava.io.IOException;Ljava.lang.ClassNotFoundException;" },
    { "initWithJavaIoByteArrayInputStream:withJavaLangClassLoader:", "init", NULL, 0x0, NULL },
  };
  static J2ObjcFieldInfo fields[] = {
    { "val$loader_", NULL, 0x1012, "Ljava.lang.ClassLoader;", NULL,  },
  };
  static J2ObjcClassInfo _FFTBase64_$1 = { "$1", "com.sponberg.fluid.util", "Base64", 0x8000, 2, methods, 1, fields, 0, NULL};
  return &_FFTBase64_$1;
}

@end
